<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Water Sort</title>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* 
         * =========================================
         * üé® CORE STYLES & THEME
         * Android-Native Look & Feel
         * =========================================
         */
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-gradient: linear-gradient(135deg, #00f260 0%, #0575e6 100%);
            --secondary-gradient: linear-gradient(135deg, #FF416C 0%, #FF4B2B 100%);
            --text-color: #ffffff;
            --text-muted: #aaaaaa;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --neon-blue: #00f2ff;
            --neon-green: #00ff88;
            --danger: #ff4757;
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Roboto', 'Segoe UI', sans-serif;
            touch-action: manipulation;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- APP HEADER --- */
        header {
            height: 60px;
            padding: 10px 20px;
            padding-top: max(10px, var(--safe-area-top));
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(18, 18, 18, 0.95);
            border-bottom: 1px solid var(--glass-border);
            z-index: 10;
        }

        .header-title {
            font-size: 1.2rem;
            font-weight: 800;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .level-badge {
            background: var(--surface-color);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* --- MAIN GAME AREA --- */
        #game-container {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden;
        }

        /* Mode Indicator */
        #mode-indicator {
            position: absolute;
            top: 10px;
            font-size: 0.8rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Timer Display (Hidden by default) */
        #timer-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--danger);
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
            display: none;
        }

        /* BOTTLE GRID */
        .bottle-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 400px;
            transition: all 0.3s ease;
        }

        /* --- BOTTLE STYLES --- */
        .bottle-wrapper {
            position: relative;
            width: 50px;
            height: 180px;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .bottle-wrapper.selected {
            transform: translateY(-20px) scale(1.05);
        }

        .bottle-wrapper.selected::after {
            content: '‚ñº';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--neon-green);
            animation: bounce 1s infinite;
        }

        .bottle {
            width: 100%;
            height: 100%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: none;
            border-radius: 0 0 25px 25px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
            position: relative;
            /* Glass Reflection */
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.1);
        }

        .bottle::before {
            /* Bottle neck */
            content: '';
            position: absolute;
            top: -10px;
            left: 5px;
            right: 5px;
            height: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
        }

        .liquid {
            width: 100%;
            position: absolute;
            bottom: 0;
            transition: height 0.4s ease-in-out, background-color 0.2s;
        }
        
        /* Kids Mode Soft Colors */
        body.kids-mode {
            --bg-color: #2c3e50;
            --primary-gradient: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
        }

        /* --- ANIMATIONS --- */
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }

        @keyframes pour-stream {
            0% { height: 0; opacity: 0; }
            20% { opacity: 1; }
            100% { height: 100%; opacity: 1; }
        }

        /* --- BOTTOM CONTROLS --- */
        .bottom-nav {
            padding: 15px;
            padding-bottom: max(15px, var(--safe-area-bottom));
            background: var(--surface-color);
            display: flex;
            justify-content: space-around;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        .nav-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            transition: color 0.2s;
        }

        .nav-btn i {
            font-size: 1.4rem;
            background: var(--glass-bg);
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .nav-btn:active i {
            transform: scale(0.9);
            background: var(--primary-gradient);
            color: white;
        }

        .nav-btn.active {
            color: var(--neon-blue);
        }
        
        .nav-btn.active i {
            color: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .modal-card {
            background: var(--surface-color);
            width: 85%;
            max-width: 350px;
            padding: 25px;
            border-radius: 25px;
            text-align: center;
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transform: scale(0.8);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal-overlay.show .modal-card {
            transform: scale(1);
        }

        .btn-primary {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            margin-top: 15px;
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 242, 96, 0.3);
        }

        .btn-secondary {
            background: var(--glass-bg);
            color: white;
            border: 1px solid var(--glass-border);
            padding: 10px 20px;
            border-radius: 50px;
            margin-top: 10px;
            width: 100%;
        }

        /* SETTINGS MENU */
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid var(--glass-border);
        }

        .toggle-switch {
            width: 40px;
            height: 22px;
            background: #444;
            border-radius: 20px;
            position: relative;
            transition: 0.3s;
        }

        .toggle-switch.on {
            background: var(--neon-green);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px;
            width: 18px; height: 18px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch.on::after {
            left: 20px;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <header>
        <div class="header-title"><i class="fas fa-flask"></i> SortIt!</div>
        <div class="level-badge">
            <i class="fas fa-star" style="color: gold;"></i> <span id="level-display">Lvl 1</span>
        </div>
        <div class="level-badge" style="background: rgba(0,0,0,0.3)">
            <i class="fas fa-coins" style="color: #ffd700;"></i> <span id="coin-display">0</span>
        </div>
    </header>

    <!-- Game Area -->
    <div id="game-container">
        <div id="mode-indicator">Classic Mode</div>
        <div id="timer-display">00:00</div>
        
        <div class="bottle-grid" id="grid">
            <!-- Bottles injected via JS -->
        </div>
    </div>

    <!-- Bottom Nav -->
    <div class="bottom-nav">
        <button class="nav-btn" onclick="Game.undo()">
            <i class="fas fa-undo"></i> Undo
        </button>
        <button class="nav-btn" onclick="Game.restartLevel()">
            <i class="fas fa-redo"></i> Restart
        </button>
        <button class="nav-btn" onclick="Game.useHint()">
            <i class="fas fa-lightbulb"></i> Hint <span style="font-size:0.6em">(<span id="hint-count">3</span>)</span>
        </button>
        <button class="nav-btn" onclick="UI.toggleSettings()">
            <i class="fas fa-cog"></i> Menu
        </button>
    </div>

    <!-- Modals -->
    <!-- Level Complete Modal -->
    <div id="modal-win" class="modal-overlay">
        <div class="modal-card">
            <h2 style="color: var(--neon-green)">Level Complete!</h2>
            <div style="font-size: 3rem; margin: 20px;">üèÜ</div>
            <p>You earned <span style="color: gold">+50 Coins</span></p>
            <button class="btn-primary" onclick="Game.nextLevel()">Next Level</button>
        </div>
    </div>

    <!-- Game Over / Time Up Modal -->
    <div id="modal-fail" class="modal-overlay">
        <div class="modal-card">
            <h2 style="color: var(--danger)">Time's Up!</h2>
            <p>Don't give up! Try again.</p>
            <button class="btn-primary" onclick="Game.restartLevel()">Try Again</button>
            <button class="btn-secondary" onclick="UI.showHome()">Main Menu</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="modal-settings" class="modal-overlay">
        <div class="modal-card">
            <h2>Settings</h2>
            <div class="settings-row" onclick="Game.setMode('CLASSIC')">
                <span>Classic Mode</span> <i class="fas fa-play"></i>
            </div>
            <div class="settings-row" onclick="Game.setMode('TIMED')">
                <span>Time Challenge</span> <i class="fas fa-stopwatch"></i>
            </div>
            <div class="settings-row" onclick="Game.setMode('KIDS')">
                <span>Kids Mode</span> <i class="fas fa-baby"></i>
            </div>
            <div class="settings-row">
                <span>Dark Mode</span>
                <div class="toggle-switch on" onclick="UI.toggleTheme(this)"></div>
            </div>
            <button class="btn-secondary" onclick="UI.closeModals()">Close</button>
        </div>
    </div>

<script>
/**
 * =================================================
 * üß† CORE GAME ENGINE
 * Handles State, Logic, and Data Persistence
 * =================================================
 */

// Configuration Constants
const CONFIG = {
    COLORS: [
        '#FF416C', '#0575E6', '#00F260', '#F2C94C', 
        '#8E2DE2', '#ff4757', '#eccc68', '#7bed9f', 
        '#70a1ff', '#5352ed', '#ff6b81'
    ],
    CAPACITY: 4,
    ANIMATION_SPEED: 300 // ms
};

// Global State
let state = {
    level: 1,
    coins: 0,
    hints: 3,
    mode: 'CLASSIC', // CLASSIC, TIMED, KIDS, HARDCORE
    bottles: [], // Array of arrays (stacks)
    selectedBottleIndex: -1,
    history: [], // For undo
    timer: null,
    timeLeft: 0,
    isAnimating: false
};

const UI = {
    grid: document.getElementById('grid'),
    levelDisplay: document.getElementById('level-display'),
    coinDisplay: document.getElementById('coin-display'),
    hintCount: document.getElementById('hint-count'),
    modeDisplay: document.getElementById('mode-indicator'),
    
    // Initialize UI updates
    updateAll() {
        this.levelDisplay.innerText = `Lvl ${state.level}`;
        this.coinDisplay.innerText = state.coins;
        this.hintCount.innerText = state.hints;
        this.renderBottles();
    },

    // Render the bottle grid based on state
    renderBottles() {
        this.grid.innerHTML = '';
        state.bottles.forEach((stack, index) => {
            const wrapper = document.createElement('div');
            wrapper.className = `bottle-wrapper ${state.selectedBottleIndex === index ? 'selected' : ''}`;
            wrapper.onclick = () => Game.handleTap(index);

            const bottle = document.createElement('div');
            bottle.className = 'bottle';

            // Render Liquids
            stack.forEach((color, i) => {
                const liquid = document.createElement('div');
                liquid.className = 'liquid';
                liquid.style.backgroundColor = color;
                liquid.style.height = '25%'; // 100% / 4
                liquid.style.bottom = `${i * 25}%`;
                // Rounded corners for top liquid
                if (i === stack.length - 1) {
                    liquid.style.borderRadius = '10px 10px 0 0';
                } else {
                    liquid.style.borderRadius = '0';
                }
                bottle.appendChild(liquid);
            });

            wrapper.appendChild(bottle);
            this.grid.appendChild(wrapper);
        });
    },

    toggleSettings() {
        document.getElementById('modal-settings').classList.add('show');
    },

    closeModals() {
        document.querySelectorAll('.modal-overlay').forEach(el => el.classList.remove('show'));
    },
    
    toggleTheme(el) {
        el.classList.toggle('on');
        document.body.classList.toggle('kids-mode');
        // If kids mode is active, ensure we switch colors
        if(document.body.classList.contains('kids-mode')) {
           state.mode = 'KIDS';
           Game.startLevel();
        } else {
           state.mode = 'CLASSIC';
           Game.startLevel();
        }
    },

    showWin() {
        document.getElementById('modal-win').classList.add('show');
        // Confetti effect could go here
    },
    
    showFail() {
        document.getElementById('modal-fail').classList.add('show');
    }
};

const Game = {
    init() {
        this.loadProgress();
        this.startLevel();
    },

    startLevel() {
        // Reset State
        state.selectedBottleIndex = -1;
        state.history = [];
        state.isAnimating = false;
        
        // Mode Specific Setup
        document.getElementById('mode-indicator').innerText = state.mode + " MODE";
        document.getElementById('timer-display').style.display = state.mode === 'TIMED' ? 'block' : 'none';
        
        if (state.timer) clearInterval(state.timer);

        // Generate Logic
        this.generateLevelData();
        
        if (state.mode === 'TIMED') {
            state.timeLeft = 60 + (state.level * 10); // More time for higher levels
            this.startTimer();
        }

        UI.updateAll();
        UI.closeModals();
    },
    
    generateLevelData() {
        // Algorithm:
        // 1. Determine number of colors (min 2, max based on level)
        // 2. Create full solved bottles
        // 3. Add 2 empty bottles
        // 4. Perform "Reverse Moves" (Scramble) to ensure solvability
        
        let colorCount = Math.min(3 + Math.floor(state.level / 2), CONFIG.COLORS.length);
        if (state.mode === 'KIDS') colorCount = 3;
        
        let bottleCount = colorCount + 2;
        let tempBottles = [];

        // Fill initial bottles (solved state)
        for (let i = 0; i < colorCount; i++) {
            let stack = [];
            for (let j = 0; j < CONFIG.CAPACITY; j++) {
                stack.push(CONFIG.COLORS[i]);
            }
            tempBottles.push(stack);
        }
        // Add empty bottles
        tempBottles.push([], []);

        // Scramble (Reverse Moves)
        // We simulate valid moves randomly N times
        let scrambles = 20 + (state.level * 5);
        
        for (let i = 0; i < scrambles; i++) {
            let src = Math.floor(Math.random() * bottleCount);
            let dest = Math.floor(Math.random() * bottleCount);
            
            if (src === dest) continue;
            
            // Logic for reverse move: 
            // We can move from SRC to DEST if:
            // 1. SRC is not empty
            // 2. DEST is not full
            // 3. (Ideally) we don't just undo the last move immediately
            
            if (tempBottles[src].length > 0 && tempBottles[dest].length < CONFIG.CAPACITY) {
                 // In scramble phase, we just move top color. 
                 // Since we start from solved, any move is "valid" in reverse entropy.
                 let color = tempBottles[src].pop();
                 tempBottles[dest].push(color);
            }
        }
        
        state.bottles = tempBottles;
    },

    handleTap(index) {
        if (state.isAnimating) return;

        // 1. First Tap (Select)
        if (state.selectedBottleIndex === -1) {
            // Cannot select empty bottle
            if (state.bottles[index].length === 0) return;
            
            state.selectedBottleIndex = index;
            UI.renderBottles(); // Update UI to show selection
            return;
        }

        // 2. Second Tap (Same Bottle -> Deselect)
        if (state.selectedBottleIndex === index) {
            state.selectedBottleIndex = -1;
            UI.renderBottles();
            return;
        }

        // 3. Second Tap (Different Bottle -> Try Move)
        this.attemptMove(state.selectedBottleIndex, index);
    },

    attemptMove(fromIdx, toIdx) {
        const fromStack = state.bottles[fromIdx];
        const toStack = state.bottles[toIdx];

        if (fromStack.length === 0) return; // Should not happen

        const colorToMove = fromStack[fromStack.length - 1];
        
        // Validation Rules:
        // 1. Destination must have space
        if (toStack.length >= CONFIG.CAPACITY) {
            this.shakeAnimation(toIdx); // Visual feedback for invalid
            state.selectedBottleIndex = -1;
            UI.renderBottles();
            return;
        }
        
        // 2. Destination must be empty OR top color must match
        const destTopColor = toStack.length > 0 ? toStack[toStack.length - 1] : null;
        
        if (destTopColor !== null && destTopColor !== colorToMove) {
             this.shakeAnimation(toIdx);
             state.selectedBottleIndex = -1;
             UI.renderBottles();
             return;
        }

        // VALID MOVE
        this.performMove(fromIdx, toIdx);
    },

    performMove(fromIdx, toIdx) {
        state.isAnimating = true;
        
        // Save state for undo
        state.history.push(JSON.parse(JSON.stringify(state.bottles)));
        if (state.history.length > 5) state.history.shift(); // Limit undo memory

        // Move logic: Move all consecutive blocks of same color
        const fromStack = state.bottles[fromIdx];
        const toStack = state.bottles[toIdx];
        const color = fromStack[fromStack.length - 1];

        // Animate (Simple state update for now, CSS handles transition)
        // In a real robust engine we calculate how many chunks to move
        // Here we move 1 chunk at a time for simplicity of animation, 
        // OR loop to move all matching top chunks. Standard game is 1 chunk.
        
        // Let's move ALL consecutive same-colored blocks that fit
        let movedCount = 0;
        
        // Helper to delay loop for animation feel
        const moveChunk = () => {
             if (fromStack.length === 0) {
                 this.finishMove();
                 return;
             }
             
             const nextColor = fromStack[fromStack.length - 1];
             if (nextColor !== color || toStack.length >= CONFIG.CAPACITY) {
                 this.finishMove();
                 return;
             }
             
             // Move data
             toStack.push(fromStack.pop());
             UI.renderBottles(); // Re-render to show change
             
             // Small delay for "pouring" effect if moving multiple
             setTimeout(moveChunk, 100); 
        };
        
        moveChunk();
    },

    finishMove() {
        state.selectedBottleIndex = -1;
        state.isAnimating = false;
        UI.renderBottles();
        this.checkWin();
    },
    
    shakeAnimation(index) {
        // Simple visual shake for invalid move
        const bottles = document.querySelectorAll('.bottle-wrapper');
        if(bottles[index]) {
            bottles[index].style.transform = 'translateX(5px)';
            setTimeout(() => bottles[index].style.transform = 'translateX(-5px)', 50);
            setTimeout(() => bottles[index].style.transform = 'translateX(0)', 100);
        }
    },

    undo() {
        if (state.history.length === 0) return;
        state.bottles = state.history.pop();
        state.selectedBottleIndex = -1;
        UI.renderBottles();
    },
    
    checkWin() {
        // Win Condition: All bottles are either empty or full with SAME color
        const isWin = state.bottles.every(stack => {
            if (stack.length === 0) return true;
            if (stack.length < CONFIG.CAPACITY) return false;
            // Check if all colors in stack are same
            return stack.every(c => c === stack[0]);
        });

        if (isWin) {
            setTimeout(() => {
                state.coins += 50;
                this.saveProgress();
                UI.showWin();
            }, 500);
        }
    },
    
    nextLevel() {
        state.level++;
        this.saveProgress();
        this.startLevel();
    },
    
    restartLevel() {
        this.startLevel();
    },
    
    useHint() {
        if (state.hints <= 0) return;
        
        // Hint Logic: Add a new empty bottle
        state.bottles.push([]);
        state.hints--;
        UI.updateAll();
        // Visual cue that a bottle appeared?
    },

    setMode(newMode) {
        state.mode = newMode;
        this.startLevel();
    },

    startTimer() {
        const display = document.getElementById('timer-display');
        state.timer = setInterval(() => {
            state.timeLeft--;
            let m = Math.floor(state.timeLeft / 60);
            let s = state.timeLeft % 60;
            display.innerText = `${m}:${s < 10 ? '0'+s : s}`;
            
            if (state.timeLeft <= 0) {
                clearInterval(state.timer);
                UI.showFail();
            }
        }, 1000);
    },

    saveProgress() {
        const data = {
            level: state.level,
            coins: state.coins,
            hints: state.hints,
            mode: state.mode
        };
        localStorage.setItem('waterSortData', JSON.stringify(data));
        UI.updateAll();
    },

    loadProgress() {
        const saved = localStorage.getItem('waterSortData');
        if (saved) {
            const parsed = JSON.parse(saved);
            state.level = parsed.level || 1;
            state.coins = parsed.coins || 0;
            state.hints = parsed.hints || 3;
            state.mode = parsed.mode || 'CLASSIC';
        }
    }
};

// Start Game
window.onload = () => Game.init();

</script>
</body>
</html>


